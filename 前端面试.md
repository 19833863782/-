| 关键词 |                        描述                        |
| :----: | :------------------------------------------------: |
| catch  |     catch用于捕捉异常或者错误时执行的回调函数      |
| async  |   使用async关键字后可以简易的创建一个Promise对象   |
| await  | 通过await关键字可以简易的获取Promise对象里面的信息 |

## 一、HTML5新增特性

#### 1、语义化标签

所谓语义标签就是看到标签我就能明白这是什么意思。以前制作网页布局基本使用div来做。div就是一个普通的块级标签，对搜索引擎来说没有任何的语义。

|         标签          |               描述               |
| :-------------------: | :------------------------------: |
|   <hrader></header>   |       定义了文档的头部区域       |
|   <footer></footer>   |       定义了文档的尾部区域       |
|      <nav></nav>      |          定义文档的导航          |
|  <section></section>  | 定义文档中的节（section、区段）  |
|  <article></article>  |      定义页面独立的内容区域      |
|    <aside></aside>    |       定义页面的侧边栏内容       |
| <detailes></detailes> | 用于描述文档或文档某个部分的细节 |
|  <summary></summary>  |   标签包含 details 元素的标题    |
|   <dialog></dialog>   |      定义对话框，比如提示框      |

使用语义化标签有利于SEO（Search Engine Optimization **搜索引擎优化**），和搜索引擎建立良好的沟通，有助于爬虫爬取更多有效的信息。因为爬虫依赖于标签来确定上下文和各个关键字的权重。也能方便团队开发和维护，增加代码可读性，遵循标准，减少差异化。

#### 2、增强型表单

HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。

**新增5个表单元素**

|         标签          |                      内容                      |
| :-------------------: | :--------------------------------------------: |
| <progress></progress> |           进度条，展示连接/下载进度            |
|    <meter></meter>    |     刻度值，用于某些计量，例如温度、重量等     |
|   <keygen></keygen>   |  提供一种验证用户的可靠方法生成一个公钥和私钥  |
|   <output></output>   |      用于不同类型的输出比如计算或脚本输出      |
| <datalist></datalist> | 用户会在他们输入数据时看到定义域选项的下拉列表 |

**新增多个表单输入类型**

|    输入类型    |            描述            |
| :------------: | :------------------------: |
|     color      |        用于选取颜色        |
|      date      | 从一个日期选择器中选择日期 |
|    datetime    |  选取一个日期（UTC时间）   |
| datetime-local |   选择一个日期（无时区）   |
|     email      |   包含email地址的输入域    |
|     month      |          选择月份          |
|      week      |           选择周           |
|      time      |        选择一个时间        |
|     number     |         数值输入域         |
|     range      |       范围数值输入域       |
|      url       |       URL地址输入域        |
|     search     |           搜索域           |
|      tel       |      定义输入电话字段      |

**新增表单属性**

|     属性     |                 描述                  |
| :----------: | :-----------------------------------: |
|  placehoder  |          输入框默认提示文字           |
|   required   |        要求输入内容是否可为空         |
|   pattern    |    描述一个正则表达式验证输入的值     |
|   min/max    |         设置元素最小值/最大值         |
|     step     |      为输入域规定合法的数字间隔       |
| height/width | 用于image类型<input>标签图像高度/宽度 |
|  autofocus   |   规定在页面加载时，域自动获得焦点    |
|   multiple   |     规定<input>元素中可选择多个值     |

#### 3、视频和音频

html5提供了音频和视频文件的标准，既使用<audio>元素。

#<audio controls>  
  <source src="" type="audio">
</audio>

#<video controls>
  <source src="" type="video">
</video>

#### 4、Canvas绘图

<canvas>元素负责在页面中设定一个区域，然后就可以通过 Javascript 动态地在这个区域中绘制图形。

<canvas id="myCanvas" width="200" height="100" style="border:1px solid #000000;">
</canvas>
#### 5、SVG绘图

**什么是svg**
SVG 是一种使用 XML 描述 2D 图形的语言，在放大或改变尺寸的情况下其图形质量不会有损失，当svg对象的属性发生变换时，浏览器会重新渲染该图形。

**与canvas的区别**

- canvas可以随时绘制2D图形（用JavaScript）

- svg是基于XML的，意味着可以操作DOM，渲染速度较慢

- 在SVG中每个形状都被当做是一个对象，如果SVG发生改变，页面就会发生重绘

- Canvas是一像素一像素地渲染，如果改变某一个位置，整个画布会重绘

  **svg用法**

<svg version="相关版本号，比如1.1">
      <circle cx = "100" cy = "50"stroke="red" stroke-width="5" fill="black"/>
      <!--
			cx:圆心的(x轴)横坐标
			cy:圆心的(y轴)纵坐标
			r:圆心的半径
			stroke：外边线条的颜色
			stroke-width：外边线条的宽度
			fill：圆填充的颜色
	  -->
</svg>

#### 6、地理位置

地理位置能够识别你的定位，并且与别人共享地理信息。

navigator.geolocation.getCurrentPosition(
    function(pos){
　　　　console.log('用户定位数据获取成功')
　　　　console.log('定位时间：',pos.timestamp)
　　　　console.log('经度：',pos.coords.longitude)
　　　　console.log('纬度：',pos.coords.latitude)
　　　　console.log('海拔：',pos.coords.altitude)
　　　　console.log('速度：',pos.coords.speed)
    },    //定位成功的回调
    function(err){ 
　　　　console.log('用户定位数据获取失败')
    }     //定位失败的回调
)

#### 7、拖放Api

**设置元素为可拖放**
<img draggable = "true">

**拖拽对象的方法**
setData(format,data)
将指定格式的数据赋值给dataTransfer对象，参数format定义数据的格式也就是数据的类型，data为待赋值的数据

getData(format)
从dataTransfer对象中获取指定格式的数据，format代表数据格式，data为数据。

clearData([format])
从dataTransfer对象中删除指定格式的数据，参数可选，若不给出，则为删除对象中所有的数据

addElement(element)
添加自定义图标。

setDragImage(element,x,y)
设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向上的距离，y设置图标与鼠标在垂直方向上的距离。

**拖拽的属性**

- none：不能把拖动的元素放在这里。这是除了文本框之外所有元素默认的值。
- move：把拖动的元素移动到放置目标。
- copy：把拖动的元素复制到放置目标。
- link：放置目标会打开拖动的元素(但拖动的元素必须是个链接URL地址)。

#### 8、Web Worker

什么是web work
当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。**web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。**您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

优点
**为js创建多线程环境。**js在主线程执行，new一个子线程在后台执行。worker完成计算的任务返回给主线程，UI交互流畅，不会被阻塞。主线程中的代码执行会导致浏览器响应阻塞，而子线程代码执行不会。主线程和子线程两者互补干扰，独立执行。

**9、Web Storage**
什么是web storage
Web 存储更加的安全与快速，这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上，它也可以存储大量的数据，而不影响网站的性能。数据以键/值对存在, web网页的数据只允许该网页访问使用。

**localStorage和sessionStorage的区别**
相同点
（1）数据都保存在浏览器客户端。
（2）同源，即同域名，同端口，同协议。
（3）操作方法相同。

不同点
（1）生命周期不同。localStorage是永久保存，除非用户手动清除数据。sessionStorage是临时保存（存在于进入页面浏览至关闭浏览器的时间）。

（2）作用域不同。浏览器有很多种，所以无法共享用户数据，也就是不同源的页面无法共享数据。

localStorage信息可以在相同浏览器中同源的不同页面，不同标签，不同窗口中共用。sessionStorage不可以在不同页面，不同标签，不同窗口中共用，即使是同源。

用法
存储

// 第一种方式，标准方法
sessionStorage.setItem('email','xxx@qq.com');
// 第二种方式，直接当成普通对象属性赋值。
sessionStorage.blog = 'http://xxxxxx';
获取

// 1. 标准方法
var email = sessionStorage.getItem('email');
// 2. 直接取属性值
var blog = sessionStorage.blog;
移除键值对

// 移除之后，再获取值，将会得到 undefined
// 根据key，移除键值对
sessionStorage.removeItem('email');
清空sessionStorage

// 全部清除
sessionStorage.clear();
localStorage与sessionStorage用法类似，就不过多赘述。

#### 10、WebSocket

概念
WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。

![](C:\Users\chenxi\Desktop\11.png)

相较于传统短轮询和长轮询的优点
较少的控制开销：在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小；
更强的实时性：由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；
保持连接状态：与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息；
更好的二进制支持：WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容；
可以支持扩展：WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。

## 二、前端性能优化

### 1.HTML优化

#### 1.压缩HTML

HTML代码压缩，将注释、空格和新行从生产文件中删除。删除所有不必要的空格、注释和中断行将减少HTML的大小，加快网站的页面加载时间，并显著减少用户的下载时间。 

#### 2.**删除不必要的注释**

注释对用户来说是没有用的，应该从生产环境文件中删除。可能需要保留注释的一种情况是：保留远端代码库（keep the origin for a library）。

#### 3.删除不必要的属性

像 type="text/javascript" or type="text/css" 这样的属性应该被移除。

<!-- Before HTML5 -->
<script type="text/javascript">
    // Javascript code
</script>

<!-- Today -->
<script>
    // Javascript code
</script>
类型属性不是必需的，因为HTML5把text/css和text/javascript作为默认值。没用的代码应在网站或应用程序中删除，因为它们会使网页体积增大。


#### 4.使用语义化标签

使用语义化标签可以提高代码的可读性和可维护性，并有助于搜索引擎优化。例如，使用 标签来定义页面头部，使用 标签来定义导航等。

**语义化优势：**

1. 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
2. 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
3. 方便其他设备解析，如盲人阅读器根据语义渲染网页
4. 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。

#### 5.减少iframe数量

尽量少用iframe标签，爬虫是不会读取iframe的内容的。

#### 6.削减DOM数量和层级数量

HTML 中标签元素越多，标签的层级越深，浏览器解析 DOM 并制作到浏览器中所花的时间就越长，所以应尽或许坚持 DOM 元素简洁和扁平化的层级。

#### 7.减少 HTTP 请求次数

将多个 CSS 和 JavaScript 文件合并为一个文件，可以减少 HTTP 请求次数，从而提高页面加载速度。同时，使用浏览器缓存可以避免每次请求相同的文件。

#### 8.减少重排重绘

重排：

当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

哪些操作可以影响重排：

添加/删除元素
display:none
移动元素位置
操作styles
offsetLeft, scrollTop, clientWidth
修改浏览器大小，字体大小
重绘：

重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。

划重点：

重排必定会引发重绘，但重绘不一定会引发重排。

### 2.JS性能优化

#### 1.javascript脚本放到页面底部

脚本的下载和执行，会阻塞其他资源（样式文件或图片）的下载。因此，将<script>标签尽量尽可能放到<body>标签的底部。

#### 2.将javascript和css从外部引入

将样式和脚本代码放到外部文件中，并使用链接或脚本标签来引用，可以提高页面加载速度。减少 DOM 操作：DOM 操作往往是页面加载速度缓慢的主要原因之一。尽量减少 DOM 操作的次数和复杂度，可以提高页面的响应速度和性能。

#### 3.删除重复的脚本

一个页面中如果有两次使用到同一个JavaScript文件，那这将对页面性能产生很大的影响。主要有以下两点：

增加了不必要的HTTP请求。
JavaScript执行所花费的时间。

#### 4.减少DOM访问

访问DOM元素是有代价的，修改DOM元素则更为昂贵，因为它会导致浏览器重新计算页面的几何变化。如下代码：
// 频繁操作dom案列

<script type="text/javascript">
  function insertHtml () {
    for(let count = 0; count < 15000; count++){
      document.getElementById('dom').innerHTML+='循环操作dom';
    }
  }
</script>

访问DOM的次数越多，代码运行速度越慢。因此，在有其他方案可以代替的时候，我们要尽量减少访问DOM的次数。

#### 5.节流与防抖

日常开发过程中，滚动事件做复杂计算频繁调用回调函数很可能会造成页面的卡顿，这时候我们更希望把多次计算合并成一次，只操作一个精确点，JS把这种方式称为debounce（防抖）和throttle（节流）。

防抖函数：

function debounce(fn, wait) {
    let timeout = null;      //定义一个定时器
    return function() {
        if(timeout !== null)
                clearTimeout(timeout);  //清除这个定时器
        timeout = setTimeout(fn, wait);
    }
}
// 处理函数
function handle() {
    console.log(Math.random());
}
// 滚动事件
window.addEventListener('scroll', debounce(handle, 1000));

节流函数：

let throttle = function(func, delay) {
    let prev = Date.now();
    return function() {
        let context = this;   //this指向window
        let args = arguments;
        let now = Date.now();
        if (now - prev >= delay) {
            func.apply(context, args);
            prev = Date.now();
        }
    }
}
function handle() {
    console.log(Math.random());
}
window.addEventListener('scroll', throttle(handle, 1000));
防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象。

#### 6.合理的ajax恳求

关于回来内容相同的恳求，没必要每次都直接从服务端拉取，合理运用 AJAX 缓存能加快 AJAX 呼应速度并减轻服务器压力。

#### 7.长列表虚拟滚动优化

虚拟列表是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表元素。下图左边就是虚拟列表的效果，可以看到只有视口内和临近视口的上下区域内的元素会被渲染。



推荐几个基于框架的开源实现：

基于React的 react-virtualized
基于Vue 的 vue-virtual-scroll-list
基于Angular的 ngx-virtual-scroller

#### 8 .代码结构的优化

1．设置Viewport：HTML的viewport可加快页面的渲染。

2．减少DOM结点：DOM结点太多会影响页面的渲染。

3．尽量使用css3动画：合理使用requestAnimationFrame动画代替setTimeout。

4．优化高频事件：scroll、touchmove等事件尽量使用函数防抖节流等进行限制。

5.  不滥用WEB字体：WEB字体需要下载、解析、重绘当前页面，尽量减少使用。

6.  文件命名规则须统一且要有意义，同类型文件归类到相同的文件夹中。

7.删除无效注释。

### 3.CSS性能优化

#### 1.尽量少用@import

主要有两个原因：

1.**使用@import引入CSS会影响浏览器的并行下载。**使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。

2.**多个@import会导致下载顺序紊乱。**在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。

#### 2.避免！important，可以选择其他选择器

因为这破坏了样式表中固有的级联规则，使调试bug变得更加困难。它很容易使用不当，而且容易成倍增加，尤其是在滥用时。您可以轻松地!important得出一个带有要覆盖的规则的元素，这时您通常不得不重构样式，或使用另一个!important规则来加剧问题。

如果你一定要使用，最好定义基本样式尽可能靠近html或body元素，并且要覆盖时，请尽量避免使用特殊性。这样，您就有足够的空间进行更改。

#### 3.不要在ID选择器前面进行嵌套其它选择器

主要有两个原因：

1.ID选择器本来就是唯一的而且人家权值那么大，前面嵌套，完全是浪费性能。

// 浪费性能。
.content #dom {}
2.除了嵌套，在ID选择器前面也不需要加标签或者其它选择器。比如 div#dom 或者.box#dom。这两种方式完全是多余的，理由就是ID在页面就是唯一的。前面加任何东西都是多余的！

// 多余写法
div#dom {}

#### 4.CSS文件压缩

这应该是最容易想到的一个方法了，通过压缩CSS文件大小来提高页面加载速度。现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。

#### 5.CSS层级嵌套最好不要超过3层

一般情况下，元素的嵌套层级不能超过3级，过度的嵌套会导致代码变得臃肿，沉余，复杂。导致css文件体积变大，造成性能浪费，影响渲染的速度！而且过于依赖HTML文档结构。这样的css样式，维护起来，极度麻烦，如果以后要修改样式，可能要使用!important覆盖。尽量保持简单，不要使用嵌套过多过于复杂的选择器。

#### 6.删除无用的css

我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。

#### 7.慎用*通配符

有时候可能会写下面这种代码来消除一些标签的默认样式或统一浏览器对标签渲染的差异化

*{
  margin：0；
  padding：0;
}
 开发时尽量避免使用通配符选择器。

#### 8.删除不必要的单位和零

CSS 支持多种单位和数字格式，可以删除尾随和跟随的零，零始终是零，添加维度不会为包含的信息附带任何价值。

.dom {
  padding: .2px;
  margin: 24px;
  width: 20px;
}

####  9.异步加载非首屏css

CSS会阻塞DOM的渲染，所以我们将首屏关键CSS内联后，剩余的非首屏CSS内容可以使用外部CSS，并且异步加载，防止非首屏CSS内容阻塞页面的渲染。

#### 10.将样式表放到页面顶部

我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML 页面就是进度条。当浏览器逐步加载页面头部，导航条，logo 等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。

#### 11.不使用IE的Filter

在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。

#### 12.检测工具推荐

给大家推荐两个检测和优化css的工具：

Online CSS Analyzer - Project Wallace

CSS Performance Testing Tool — Maker's Aid


### 4.图片优化

#### 1.根据实际需要选择色深，压缩。

减小图片的大小可以减少页面加载时间。可以使用图片压缩工具来压缩图片，以减小文件大小。

#### 2.小图片引入雪碧图。

雪碧图（CSS Sprite）又叫CSS精灵图主要用于把一堆小图标整合在一张背景透明的大图上，通过设置对应的位置来显示不同的图片，目的是大幅减轻服务器对图片的请求数量，是前端性能优化的一种方式。
优势： 

1、减少网页的HTTP请求，提高页面性能
2、减少图片命名的困扰

劣势：

1、需要计算每个图片的位置
2、后期维护困难

#### 3.图片懒加载

一般来说，我们访问网站页面时，其实很多图片并不在首屏中，如果我们都加载的话，相当于是加载了用户不一定会看到图片， 这显然是一种浪费。解决的核心思路就是懒加载：实现方式就是先不给图片设置路径，当图片出现在浏览器可视区域时才设置真正的图片路径。

#### 4..缩小 favicon.ico 并缓存

有利于 favicon.ico 的重复加载，由于一般一个 Web 运用的 favicon.ico 是很少改动的。

#### 5.img图片的alt属性要写, 合理使用target="_blank"

<img src="图片地址" alt="图片keyword"/> alt属性一定要写
合理而不频繁使用target="_blank" 是可以在一定程度上位站点带来回旋流量和点击的。同一时候。在细节上使用 target="_blank" ，可以增强站点总体用户体验 。

#### 6.采用svg图片或者字体图标

因为字体图标或者SVG是矢量图，代码编写出来的，放大不会失真，而且渲染速度快。字体图标使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便，还有一个优点是生成的文件特别小。

#### 7.Base64

将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%。

## 三、CSS兼容浏览器问题

1.从浏览器内核的角度来看，浏览器兼容性问题可分为以下三类：
1.渲染相关：和样式相关的问题，即体现在布局效果上的问题。
2.脚本相关：和脚本相关的问题，包括JavaScript和DOM、BOM方面的问题。对于某些浏览器的功能方面的特性，也属于这一类。
3.其他类别：除以上两类问题外的功能性问题，一般是浏览器自身提供的功能，在内核层之上的。
二、浏览器兼容性相关问题及其解决思路
1、目前，各主流浏览器的新版本，对于 W3C 的标准支持很好，因此，首先保证代码符合 W3C 的标准，这是解决浏览器兼容问题的前提。
其次，对于某些支持受限的属性，针对不同的浏览器添加相应的前缀，比如-webkit-、-o-、-moz-。

2、不同浏览器默认的内外边距不同的问题
解决：*{margin:0;padding:0;}

3、不同浏览器水平居中的问题：ie6-7文本居中，嵌套的块元素也会居中 ，ff /opera /safari /ie8文本会居中，嵌套块不会居中.
解决: 块元素设置 margin-left:auto;margin-right:auto 或margin:0 auto; 或外层嵌套div设置<div align=”center”></div>浮动块元素的居中：<div style="margin:0px auto;"><div style="float:left;"></div></div>

4、不同浏览器垂直居中的问题 ： 在浏览器中 想要垂直居中，设置vertical-align:middle; 不起作用。例如：ie6下文本与文本输入框对不齐，需设置 vertical-align:middle，但是文本框的内容不会垂直居中
解决： 给容器设置一个与其高度相同的行高 line-height:与容器的height一样

5、不同浏览器关于高度问题 ： 如果是动态地添加内容，高度最好不要定义。浏览器可以自动伸缩，然而如果是静态的内容，高度最好定好。 如果设定了高度，内容过 多时，ie6下会自动增加高度、其他浏览器会超出边框
解决： 1.设置overflow:hidden; 2.高度自增height:auto!important;height:100px;

## 四、Vue2与Vue3的区别

#### 1.速度更快

```
Vue3`相比`Vue2
```

- 重写了虚拟`Dom`实现
- 编译模板的优化
- 更高效的组件初始化
- `undate`性能提高1.3~2倍
- `SSR`速度提高了2~3倍

#### 2.体积更小

通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的

能够tree-shaking，有两大好处：

对开发人员，能够对vue实现更多其他的功能，而不必担忧整体体积过大
对使用者，打包出来的包体积变小了
vue可以开发出更多其他的功能，而不必担忧vue打包出来的整体体积过多

#### 3.更易维护

##### compositon Api

- 可与现有的`Options API`一起使用

- 灵活的逻辑组合与复用

- `Vue3`模块可以和其他框架搭配使用

- ##### 更好的Typescript支持

  `Vue3`是基于`typescipt`编写的，可以享受到自动的类型定义提示

## 五、Vue-router     是用来实现SPA（单页应用程序）的插件

#### 1.前端路由是什么？

前端路由是在保证只有一个HTML页面的情况下，通过对每个视图展示形式匹配一个特殊的url来实现所谓的切换效果。不会重新向服务端发送请求，也不会跳转页面。无论是刷新、前进、还是后退，都可以通过特殊url实现。

#### 2.单页面应用的优缺点（SPA）

单页面应用程序将所有的活动局限于一个Web页面中，在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成，单页面应用不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，单页面应用可以提供较为流畅的用户体验。
所谓的页面跳转，多个页面之间的切换是利用JS动态的变换HTML的内容，加载的时候不是加载整个页面，而是某个指定的容器中的内容。

**单页面应用的优点**
**良好的交互体验**
单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过Ajax异步获取，没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象，页面显示流畅

**良好的前后端工作分离模式**
后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端

**减轻服务器压力**
单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍

**缺点**
不会记住用户的操作记录

首屏加载慢

## 六、Vuex

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

**Vuex的好处**

① 能够在Vuex中集中管理共享的数据，易于开发和后期维护

② 能够高效的实现组件之间的数据共享，提高开发效率

③ 存储在Vuex中的数据都是响应式的，能够实时保持数据与页面的同步

## 七、什么是Element，vant等

#### 1.Element

Element UI是一个基于Vue.js的开源UI组件库，专为开发者提供了一套优雅而灵活的UI组件。它包含了各种常用的Web组件，如按钮、表单、导航等，以及高级组件，如日期选择器、对话框等。Element UI的设计风格简洁美观，易于定制，使其成为许多Vue.js项目的首选UI框架。

#### 2.vant

Vant是一个**轻量、可靠的移动端组件库**，于 2017 年开源。

性能极佳，组件平均体积小于 1KB（min+gzip）
🚀 65+ 个高质量组件，覆盖移动端主流场景
💪 使用 TypeScript 编写，提供完整的类型定义
💪 单元测试覆盖率超过 90%，提供稳定性保障
📖 提供完善的中英文文档和组件示例
📖 提供 Sketch 和 Axure 设计资源
🍭 支持 Vue 2、Vue 3 和微信小程序
🍭 支持主题定制，内置 700+ 个主题变量
🍭 支持按需引入和 Tree Shaking
🍭 支持服务器端渲染
🌍 支持国际化和语言包定制

#### 3.ECharts

ECharts是一款基于JS的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。

ECharts 提供了常规的折线图、[柱状图](https://baike.baidu.com/item/柱状图/10963683?fromModule=lemma_inlink)、[散点图](https://baike.baidu.com/item/散点图/10065276?fromModule=lemma_inlink)、[饼图](https://baike.baidu.com/item/饼图/10816566?fromModule=lemma_inlink)、[K线图](https://baike.baidu.com/item/K线图/85028?fromModule=lemma_inlink)，用于统计的[盒形图](https://baike.baidu.com/item/盒形图/2258542?fromModule=lemma_inlink)，用于地理数据可视化的地图、[热力图](https://baike.baidu.com/item/热力图/2663612?fromModule=lemma_inlink)、[线图](https://baike.baidu.com/item/线图/4398556?fromModule=lemma_inlink)，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的[平行坐标](https://baike.baidu.com/item/平行坐标/8649083?fromModule=lemma_inlink)，还有用于 BI 的[漏斗图](https://baike.baidu.com/item/漏斗图/57642726?fromModule=lemma_inlink)，[仪表盘](https://baike.baidu.com/item/仪表盘/9800784?fromModule=lemma_inlink)，并且支持图与图之间的混搭。

#### 4.什么是异步编程

**异步编程**是一种编程技术，‌它允许程序在等待某些操作（‌如网络请求或数据处理）‌完成的同时继续执行其他任务。‌这种技术在现代Web开发中变得尤为重要，‌因为它能有效处理耗时操作，‌确保用户体验不受阻塞。‌异步编程通过利用线程技术或类似机制，‌使得当执行一个占用时间长的任务时，‌不会阻止用户进行其他工作，‌而是在任务完成时通知用户。‌

#### 5.什么是回调函数

是一个被作为参数传递的函数，在特定事件发生或条件满足时被调用执行。回调函数通常用于响应特定的事件或条件，比如在异步操作完成后调用一个预定义的函数来处理结果。在编程中，回调函数可以大大提升编程效率，也使得程序更加灵活和可扩展。回调函数可以通过[函数指针**](https://www.baidu.com/s?wd=函数指针&usm=3&ie=utf-8&rsv_pq=8d554ee4002566e4&oq=什么是回调函数&rsv_t=4af3bd35I52JPcQ5jnfqBzdU2eblTcwVYgrAi6UXhL0VdwJ6dru%2FRLzkAuc&sa=re_dqa_zy&icon=1)、[仿函数**](https://www.baidu.com/s?wd=仿函数&usm=3&ie=utf-8&rsv_pq=8d554ee4002566e4&oq=什么是回调函数&rsv_t=4af3bd35I52JPcQ5jnfqBzdU2eblTcwVYgrAi6UXhL0VdwJ6dru%2FRLzkAuc&sa=re_dqa_zy&icon=1)或[匿名函数**](https://www.baidu.com/s?wd=匿名函数&usm=3&ie=utf-8&rsv_pq=8d554ee4002566e4&oq=什么是回调函数&rsv_t=4af3bd35I52JPcQ5jnfqBzdU2eblTcwVYgrAi6UXhL0VdwJ6dru%2FRLzkAuc&sa=re_dqa_zy&icon=1)等方式实现。

简单来说，回调函数就相当于一个中断处理函数，由系统在符合设定的条件时自动调用。为此，需要做三件事：**声明回调函数、定义回调函数、设置触发条件**，就是在函数中把回调函数名称转化为地址作为一个参数，以便于系统调用。

#### 6.什么是promise

**前端Promise**是一种异步编程模式，‌用于处理异步操作，‌特别是在前端开发中。‌Promise在JavaScript中提供了一种更简洁、‌优雅的方式来处理异步代码，‌提高了代码的可读性和可维护性。‌它被广泛应用于处理网络请求、‌事件处理、‌定时器等异步操作。‌

Promise对象代表一个尚未完成但最终会完成的操作，‌具有三种状态：‌pending（‌进行中）‌、‌fulfilled（‌已成功）‌和rejected（‌已失败）‌。‌当异步操作完成时，‌Promise对象会从pending状态转变为fulfilled或rejected状态，‌并执行相应的回调函数。‌使用Promise可以通过链式调用的方式，‌以更清晰、‌可读性更好的方式编写异步代码。‌它提供了`then()`方法用于注册成功的回调函数，‌以及`catch()`方法用于注册失败的回调函数。‌同时，‌Promise还支持`Promise.all()`和`Promise.race()`等方法，‌用于处理多个异步操作的结果。‌

#### 7.Axios

Axios是一个基于Promise的网络请求库，它可以运行在浏览器和Node.js环境中。Axios本质上是对原生XHR（XMLHttpRequest）的封装，并使用Promise技术实现异步操作，这使得处理复杂的请求和响应更加简单和直观。

主要关键词及作用：

| 关键词 |                        描述                        |
| :----: | :------------------------------------------------: |
| catch  |     catch用于捕捉异常或者错误时执行的回调函数      |
| async  |   使用async关键字后可以简易的创建一个Promise对象   |
| await  | 通过await关键字可以简易的获取Promise对象里面的信息 |

Axios的主要特点包括：

1. **支持浏览器和Node.js**：Axios既可以在浏览器中使用，也可以在Node.js环境中使用，提供了统一的API用于发起HTTP请求。
2. **Promise支持**：Axios基于Promise实现异步操作，这意味着你可以使用`.then()`和`.catch()`等方法来处理请求的成功和失败情况。
3. **拦截请求和响应**：Axios允许你在请求和响应被发送或接收时拦截它们，这样你可以进行自定义的处理，例如在请求发送前设置token，在响应处理后统一处理错误信息等。
4. **转换请求和响应数据**：Axios可以自动转换请求和响应的数据，例如自动将JSON数据转换成JavaScript对象。
5. **取消请求**：你可以使用Axios的取消功能来取消正在进行的请求。
6. **客户端防御XSRF**：Axios能够保护客户端免受跨站请求伪造（XSRF）的攻击。
7. **多种请求方式**：Axios支持多种HTTP请求方式，包括GET、POST、PUT、DELETE等，满足各种场景下的需求。

在使用Axios时，你可以使用不同的方式来发起请求。例如，你可以使用`axios(config)`方式，直接将相关配置（包括请求URL）作为参数传入到axios方法中；或者你也可以使用`axios(url[, config])`方式，第一个参数传入请求URL，第二个参数传入其他配置参数。

总的来说，Axios是一个功能强大且易于使用的网络请求库，它可以帮助你更轻松地处理HTTP请求和响应。

## 八、git及常用指令

Git是一个开源的分布式版本控制系统，可以有效、高效地处理从小型到大型项目的版本管理。以下是Git的介绍和一些常用命令。

介绍

Git是一个开源的分布式版本控制系统，可以有效、高效地处理从小型到大型项目的版本管理。

常用命令

配置Git的用户名和邮箱

`git config --global user.name "your_name"`
`git config --global user.email "your_email@example.com"`

初始化新的Git仓库

`git init`

克隆现有的仓库

`git clone https://github.com/user/repo.git`

查看文件状态

`git status`

添加文件到暂存区

`git add <file>`
`git add .`

提交更改

`git commit -m "commit message"`

推送到远程仓库

`git push origin <branch>`

拉取远程仓库的最新更改

`git pull`

查看提交历史

`git log`

创建分支

git branch <branch>

切换分支

git checkout <branch>

创建并切换到新分支

git checkout -b <branch>

合并分支

git merge <branch>

删除分支

git branch -d <branch>

撤销更改

git checkout -- <file>   # 撤销工作区的更改
git reset HEAD <file>    # 撤销暂存区的更改

创建标签

git tag <tagname>

推送标签到远程

git push origin <tagname>

拉取标签信息

git fetch --tags

删除本地分支或标签

git branch -d <branch>
git tag -d <tagname>

删除远程分支或标签

git push origin --delete <branch>
git push origin :refs/tags/<tagname>

这些命令涵盖了Git的基本操作，更复杂的操作可能涉及到分支策略、合并策略、冲突解决等高级主题。

## 九、this指向、作用域链、原型链、闭包、构造函数、箭头函数

#### 1.this指向

this 是 JavaScript 中的一个关键字。依赖于函数调用的上下文条件。

函数的this指向谁，其实可以分为两种情况讨论：

普通函数的this:
**普通函数的this指向函数调用者，如果找不到调用者，默认指向window。**普通函数的this指向可以通过call\apply\bind去改变

箭头函数的this:

**箭头函数本身并无this，箭头函数的this由定义箭头函数时所处的作用域决定，即箭头函数的this永远指向定义箭头函数时所在的作用域的this（也可以说是上层作用域，强调的是作用域！）**。箭头函数的this只和定义时的作用域this有关，和调用者无关，和调用环境无关，也永远不会改变。
this在不同应用场景中的取值
普通函数（非箭头函数）被调用时的this指向
普通函数（非箭头函数）被调用时，this的指向是window

#### 2.作用域链

**1、作用域**
作用域是一套规则，用来确定在何处以及如何查找标识符。在 JS 中作用域分为全局作用域和函数作用域，另外函数作用域可以互相嵌套。在下面的例子中，存在着全局作用域 fn 作用域和 bar作用域，他们相互嵌套。
    <script>
        var a = 1;
        var b = 2;

        function fn(x) {
            var a = 10;
     
            function bar(x) {
                var a = 100;
                b = x + a;
                return b;
            }
            bar(20);
            bar(200);
        }
        fn(0);
    </script>
**2、作用域链**
各个作用域的嵌套关系组成一条作用域链。例子中 bar 函数的作用域链式 bar -> fn -> 全局， fn函数保存在作用域链式 fn -> 全局
作用域链主要是进行标识符（变量和函数）的查询，标识符解析就是沿着作用域链一级一级的搜索标识符的过程，而作用域链就是保证对变量和函数的有序访问。
（1）如果自身作用域中声明该变量，则无需使用作用域链
在上面的例子中，如果要在 bar 函数中查询变量 a ，则直接使用 LHS 查询，赋值为 100 即可。
（2）如果自身作用域中未声明该变量，则需要使用作用域链进行查找

#### 3.原型链

原型链就是顺着`__proto__`所在的一条链子，这样说可能不是很好理解，下面来看例子你就会理解。

首先你需要只知道的是，处在原型上的对象，是可以顺着自己所在原型链向上找，然后可以使用上面的方法或者属性。主要作用就是减少内存消耗，提高代码的复用率。

function A(){}
A.prototype.f1=()=>{console.log('f1')}
A.prototype.f2=()=>{console.log('f2')}
A.prototype.f3=()=>{console.log('f3')}

const a1=new A()
const a2=new A()
const a3=new A()

a1.f1()  // f1
a2.f1()  // f1
a3.f1()  // f1

把一些公共的方法添加到原型上，这样我们实例化的每个对象就都可以使用这些这些原型上的方法了。如果我们不把方法添加到原型上，而现在需求是需要每个实例都能使用上面的这些方法,那我们只能将这些方法都添加到实例上例：a1.f1=f1。如果我们把这些方法添加到原型上，实例使用时，只需要往原型上找就行，而且所有实例使用的同一个原型。对比一看，是不是省了很多内存开销。

#### 4.闭包

先来看一下关于闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

闭包是一种特殊的函数，它能够访问并操作其词法作用域（即定义时的作用域）中未在其自身函数体中声明的变量。换句话说，闭包是由函数及其相关的引用环境组合而成的，这个环境包含了该函数创建时所能访问的所有局部变量。当函数作为返回值被另一个函数返回时，就形成了闭包。闭包可以用于封装数据、创建私有变量、以及延迟计算等场景。

闭包的特点包括：

1. 函数内部可以访问外部函数的变量。
2. 返回的内部函数保持对外部变量的引用，即使外部函数执行完毕。
3. 由于持久的引用，闭包可以在生命周期内维护状态。

#### 5.构造函数

**构造函数是一种特殊的成员函数，它的主要功能是在创建对象时初始化对象，即为对象的成员变量赋初始值。**构造函数与类名相同，并且可以被重载，即根据参数个数的不同或参数类型的不同来区分不同的构造函数。在Java语言中，构造函数也被称为构造方法，它与C++语言中的构造函数类似。构造函数可以有任意类型的参数，但不能有返回值，也不能被说明为void类型。构造函数一般被声明为公有函数，程序不能直接调用构造函数，它是在创建对象时由系统自动调用的。

#### 6.箭头函数

箭头函数是一种简写函数的语法，也称为lambda函数或者箭头表达式。它使用箭头(=>)来定义函数，通常用于定义匿名函数或回调函数。

箭头函数有以下几个特点：

1. 箭头函数总是匿名的，因为它们没有函数名。

2. 箭头函数没有自己的this，它们使用父级作用域中的this。

3. 箭头函数的参数列表放在括号中，如果没有参数则可以省略括号。

4. 如果箭头函数只有一行代码，它可以省略花括号和return关键字，该行代码会自动成为返回值。

